{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>Welcome to the documentation for NEMO initial conditions (pyIC)</p>"},{"location":"#introduction","title":"Introduction","text":"<p>pyIC is a python package to generate initial conditions for regional NEMO model configurations.</p>"},{"location":"#dependecies","title":"Dependecies","text":"<p>pyIC is insatlled under a conda/mamba environment to aid wider distribution and to facilitate development. The key dependecies are listed below:</p> <ul> <li>cf_xarray</li> <li>netcdf4</li> <li>numpy</li> <li>xarray</li> <li>xesmf</li> <li>xgcm</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<p>To get started, check out and set up an instance of the pyIC GitHub repository:</p> <pre><code>export PYIC_DIR=$PWD/pyIC\ngit clone git@github.com:NOC-MSM/pyIC.git\n</code></pre> Helpful Tip... <ul> <li>It is not advised to checkout the respository in your home directory.</li> </ul> <p>Creating a specific conda virtual environment is highly recommended (click here for more about virtual enviroments). Load conda (e.g. through anaconda/miniforge) and create the environment through the provided <code>environment.yml</code> file.</p> <pre><code>cd $PYIC_DIR\nconda env create -n pyic -f environment.yml\n</code></pre> <p>Activate the new environment</p> <pre><code>conda activate pyic\n</code></pre> <p>Install pyIC</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>pyIC revolves around its <code>GRID</code> class, which takes a gridded data set as input (such as a <code>netCDF</code>, or any other file that can be opened using <code>xarray</code>). Then we use the Regridder within <code>xesmf</code> to regrid data on one <code>GRID</code> to another.</p> <p>A basic example is included within the <code>pyic_exe.py</code> script and can be run from the command line. Further arguments are required to specify x, y, depth if they are not on a list of commonly inferred ones.</p> <pre><code>python pyic_exe.py --source /path/to/source/grid.nc --destination /path/to/destination/grid.nc --in_data /path/to/source/data.nc --out_path /path/to/destination/regridded_data.nc\n</code></pre> <p>These flags can be simplified to <code>-s</code>, <code>-d</code>, <code>-i</code> and <code>-o</code> respectively.</p> <p><code>--out_path</code> is optional and will be assumed to be <code>regridded.nc</code> if it is not passed to <code>pyic_exe.py</code>.</p>"},{"location":"#example-scripts","title":"Example scripts","text":"<p>Several example python scripts can be found in the <code>examples/</code> subdirectory. These are split into two rough categories: synthetic data (with scripts to create said data) and data from NEMO and other models.</p>"},{"location":"GRID/","title":"The GRID class","text":"<p>The GRID class forms the bare bones of pyIC. Gridded data form the means to create the GRID instances.</p>"},{"location":"GRID/#inputs","title":"Inputs","text":"<p>GRID has the following arguments:</p> <ul> <li><code>data_filename</code>: a path to a gridded data set readable by <code>xarray</code>.</li> <li><code>dataset</code>: an <code>xarray</code> Dataset.</li> <li><code>ds_lon_name</code>: optional str - the variable name for longitude (can be inferred from <code>self.lon_names</code>).</li> <li><code>ds_lat_name</code>: optional str - the variable name for latitude (can be inferred from <code>self.lat_names</code>).</li> <li><code>ds_z_name</code>: optional str - the vertical coordinate if it exists.</li> <li><code>ds_time_counter</code>: optional str - the variable name for time, inferred as <code>time_counter</code> if not provided.</li> <li><code>convert_to_z_grid</code>: optional bool - whether to regrid vertically using arguments in <code>z_kwargs</code> (uses xgcm).</li> <li><code>z_kwargs</code>: optional dict - arguments for vertical regridding. Must contain as a minimum <code>{'variable':'some_variable','target':xr.DataArray/np.array of levels to interpolate to}</code>.</li> <li><code>equation_of_state</code>: optional str - used to check that the equation of state for source and destination data is the same.</li> </ul> <p>You should provide one of <code>data_filename</code> or <code>dataset</code> for reasons that should be obvious: we need gridded data for the GRID objects.</p>"},{"location":"GRID/#vertical-regridding","title":"Vertical regridding","text":"<p>This is still under construction but uses xgcm's regridding tool. You may decide to regrid your data vertically first, and then create a pyIC GRID object, either by saving to a netCDF, or using the generated <code>xarray</code> Dataset as an input to the pyIC grid class.</p>"},{"location":"regrid/","title":"regrid.py","text":"<p>This file contains useful functions for regridding.</p> <p>This is usually a two step process:</p> <ol> <li>Read the source and destination grids in using the GRID class.</li> <li>Make a regridder using <code>make_regridder</code> to regrid from source GRID to destination GRID.</li> <li>Pass <code>regrid_data</code> the regridder and data on the same grid as the source GRID.</li> </ol> <p>You can now save the regridded data as a netcdf, and pass this as an option to <code>regrid_data</code>.</p>"},{"location":"references/grid/","title":"Grid","text":""},{"location":"references/grid/#module-grid","title":"module <code>grid</code>","text":""},{"location":"references/grid/#class-grid","title":"class <code>GRID</code>","text":"<p>Class that provides methods to handle and regrid gridded datasets for NEMO.</p> <p></p>"},{"location":"references/grid/#method-__init__","title":"method <code>__init__</code>","text":"<pre><code>__init__(\n    data_filename=None,\n    dataset=None,\n    ds_lon_name=None,\n    ds_lat_name=None,\n    ds_z_name=None,\n    ds_time_counter=\"time_counter\",\n    convert_to_z_grid=False,\n    z_kwargs={},\n    equation_of_state=None,\n)\n</code></pre> <p>Initialize the GRID class with the specified dataset and coordinate names.</p> <p>Args:</p> <ul> <li><code>data_filename</code> (str, optional): Path to the dataset file on the desired grid.</li> <li><code>dataset</code> (xarray.Dataset, optional): xarray Dataset object</li> <li><code>ds_lon_name</code> (str, optional): The name of the longitude variable in the dataset. If None, it will be inferred from common names.</li> <li><code>ds_lat_name</code> (str, optional): The name of the latitude variable in the dataset. If None, it will be inferred from common names.</li> <li><code>ds_z_name</code> (str, optional): The name of the depth coordinate, assume z.</li> <li><code>ds_time_counter</code> (str, optional): The name of the time counter variable in the dataset, assume time_counter.</li> <li><code>convert_to_z_grid</code> (bool, optional): whether to convert from a sigma-level grid to a z-level grid.</li> <li><code>z_kwargs</code> (dict, optional): additional details required for vertical conversion</li> <li><code>equation_of_state</code> (str, optional): the equation of state of the data.</li> </ul> <p></p>"},{"location":"references/grid/#method-extract_lonlat","title":"method <code>extract_lonlat</code>","text":"<pre><code>extract_lonlat(lon_name=None, lat_name=None)\n</code></pre> <p>Extract longitude and latitude data arrays from the dataset.</p> <p>Args:</p> <ul> <li><code>lon_name</code> (str, optional): The name of the longitude variable. If None, it will be inferred.</li> <li><code>lat_name</code> (str, optional): The name of the latitude variable. If None, it will be inferred.</li> </ul> <p>Returns:</p> <ul> <li><code>tuple</code>: A tuple containing the longitude DataArray, latitude DataArray, and their respective names.</li> </ul> <p>Raises:</p> <ul> <li><code>Exception</code>: If the specified longitude or latitude variable is not found in the dataset.</li> </ul> <p></p>"},{"location":"references/grid/#method-get_dim_varname","title":"method <code>get_dim_varname</code>","text":"<pre><code>get_dim_varname(dimtype)\n</code></pre> <p>Retrieve the variable name corresponding to a specified dimension type (longitude or latitude).</p> <p>Args:</p> <ul> <li><code>dimtype</code> (str): The type of dimension ('longitude' or 'latitude').</li> </ul> <p>Returns:</p> <ul> <li><code>str</code>: The variable name for the specified dimension.</li> </ul> <p>Raises:</p> <ul> <li><code>Exception</code>: If the variable name for the specified dimension is not found in the dataset.</li> </ul> <p></p>"},{"location":"references/grid/#method-make_common_coords","title":"method <code>make_common_coords</code>","text":"<pre><code>make_common_coords(z_name, lon_name, lat_name, time_counter=\"time_counter\")\n</code></pre> <p>Align the grid dataset with common coordinate names for regridding.</p> <p>Args:</p> <ul> <li><code>z_name</code> (str): name of the depth coordinate.</li> <li><code>lon_name</code> (str): The name of the longitude coordinate.</li> <li><code>lat_name</code> (str): The name of the latitude coordinate.</li> <li><code>time_counter</code> (str, optional): The name of the time counter variable. Defaults to \"time_counter\".</li> </ul> <p>Returns:</p> <ul> <li><code>xarray.Dataset</code>: The dataset with standardized coordinate names and attributes for regridding.</li> </ul> <p></p>"},{"location":"references/grid/#method-open_dataset","title":"method <code>open_dataset</code>","text":"<pre><code>open_dataset(filename, convert_to_z, z_kwargs)\n</code></pre> <p>Open a dataset from a specified filename using xarray.</p> <p>Args:</p> <ul> <li><code>filename</code> (str): The path to the dataset file.</li> <li><code>convert_to_z</code> (bool): whether to convert data to a z grid</li> <li><code>z_kwargs</code> (dict): arguments for vertical conversion</li> </ul> <p>Returns:</p> <ul> <li><code>xarray.Dataset</code>: The opened dataset.</li> </ul> <p></p>"},{"location":"references/grid/#method-vertical_convert","title":"method <code>vertical_convert</code>","text":"<pre><code>vertical_convert(ds_grid, z_kwargs, periodic=False)\n</code></pre> <p>Vertical conversion of data using xgcm's built in vertical conversion with their <code>Grid</code> class.</p> <p>Args:</p> <ul> <li><code>ds_grid</code> (xarray.Dataset): data set on some metric of depth (let's say salinity)</li> <li><code>z_kwargs</code> (dict): dict containing at least {'variable':str/list of strs,'target':array_like}. Other arguments are as in the xgcm documentation:</li> <li><code>https</code>: //xgcm.readthedocs.io/en/latest/transform.html?highlight=vertical</li> <li><code>periodic</code> (bool): passed to xgcm.Grid.</li> </ul> <p>Returns:</p> <ul> <li><code>xarray.Dataset</code>: Vertically regridded data set.</li> </ul> <p>This file was automatically generated via lazydocs.</p>"},{"location":"references/pyic_exe/","title":"Pyic exe","text":""},{"location":"references/pyic_exe/#module-pyic_exe","title":"module <code>pyic_exe</code>","text":""},{"location":"references/pyic_exe/#function-main","title":"function <code>main</code>","text":"<pre><code>main()\n</code></pre> <p>Call pyic from the command line for simple regridding tasks.</p> <p>Requires arguments for the source and destination grids, and the data to be regridded from the source to the destination grid.</p> <p>This file was automatically generated via lazydocs.</p>"},{"location":"references/regrid/","title":"Regrid","text":""},{"location":"references/regrid/#module-regrid","title":"module <code>regrid</code>","text":"<p>Group of functions to regrid GRIDs to other variations.</p> <p></p>"},{"location":"references/regrid/#function-make_subset_and_mask","title":"function <code>make_subset_and_mask</code>","text":"<pre><code>make_subset_and_mask(source_grid, destination_grid)\n</code></pre> <p>Create a subset of the source grid that matches the area of the destination grid.</p> <p>Args:</p> <ul> <li><code>source_grid</code> (GRID): The source grid instance.</li> <li><code>destination_grid</code> (GRID): The destination grid instance.</li> </ul> <p></p>"},{"location":"references/regrid/#function-subset_mask","title":"function <code>subset_mask</code>","text":"<pre><code>subset_mask(source_grid, destination_grid, return_masks=False)\n</code></pre> <p>Create a mask for the source grid that covers the same area as the destination grid.</p> <p>Args:</p> <ul> <li><code>source_grid</code> (GRID): The source grid instance.</li> <li><code>destination_grid</code> (GRID): The destination grid instance.</li> <li><code>return_masks</code> (bool): If True, return the masks for longitude and latitude.</li> </ul> <p>Returns:</p> <ul> <li><code>tuple</code>: Longitude and latitude masks if return_masks is True.</li> </ul> <p></p>"},{"location":"references/regrid/#function-make_subset","title":"function <code>make_subset</code>","text":"<pre><code>make_subset(source_grid, subset_lon_bool=None, subset_lat_bool=None)\n</code></pre> <p>Create a subset of the source grid based on the provided longitude and latitude masks.</p> <p>Args:</p> <ul> <li><code>source_grid</code> (GRID): The source grid instance.</li> <li><code>subset_lon_bool</code> (array-like, optional): Boolean mask for longitude.</li> <li><code>subset_lat_bool</code> (array-like, optional): Boolean mask for latitude.</li> </ul> <p>Returns:</p> <ul> <li><code>xarray.Dataset</code>: The subsetted dataset.</li> </ul> <p></p>"},{"location":"references/regrid/#function-is_superset_of","title":"function <code>is_superset_of</code>","text":"<pre><code>is_superset_of(source_grid, destination_grid, return_indices=False, tolerance=0)\n</code></pre> <p>Check if the source grid is a superset of the destination grid.</p> <p>Args:</p> <ul> <li><code>source_grid</code> (GRID): The source grid instance.</li> <li><code>destination_grid</code> (GRID): The destination grid instance.</li> <li><code>return_indices</code> (bool): If True, return indices of the source grid for insetting.</li> <li><code>tolerance</code> (float): Tolerance for checking bounds.</li> </ul> <p>Returns:</p> <ul> <li><code>tuple</code>: Indices of the source grid if return_indices is True.</li> </ul> <p>Raises:</p> <ul> <li><code>Exception</code>: If the source grid is not a superset of the destination grid.</li> </ul> <p></p>"},{"location":"references/regrid/#function-make_regridder","title":"function <code>make_regridder</code>","text":"<pre><code>make_regridder(\n    source_grid,\n    destination_grid,\n    landsea_mask=None,\n    regrid_algorithm=\"bilinear\",\n    save_weights=None,\n    reload_weights=None,\n    periodic=True,\n    ignore_degenerate=True,\n    unmapped_to_nan=True,\n    force=False,\n    check_superset=True,\n    use_inset=False,\n    parallel=False,\n)\n</code></pre> <p>Create a regridder to transform the source grid onto the destination grid.</p> <p>Args:</p> <ul> <li><code>source_grid</code> (GRID): The source grid instance.</li> <li><code>destination_grid</code> (GRID): The destination grid instance.</li> <li><code>landsea_mask</code> (str): variable name of the landsea mask.</li> <li><code>regrid_algorithm</code> (str): The regridding method to use (e.g., \"bilinear\", \"conservative\").</li> <li><code>save_weights</code> (str, optional): Path to save the regridding weights.</li> <li><code>reload_weights</code> (str, optional): Path to load existing regridding weights.</li> <li><code>periodic</code> (bool): If True, allows periodic boundaries in the regridding process.</li> <li><code>ignore_degenerate</code> (bool): If True, ignores degenerate grid cells during regridding.</li> <li><code>unmapped_to_nan</code> (bool): If True, sets unmapped values to NaN in the output.</li> <li><code>force</code> (bool): If True, skip superset checks and force regridding (equivalent to setting both check_superset and use_inset to False).</li> <li><code>check_superset</code> (bool): If True, check source is a superset of destination.</li> <li><code>use_inset</code> (bool): If True, make inset of source. Sometimes results in a type error.</li> </ul> <p>Returns:</p> <ul> <li><code>xesmf.Regridder</code>: The regridder object for transforming data.</li> </ul> <p></p>"},{"location":"references/regrid/#function-vertical_regrid","title":"function <code>vertical_regrid</code>","text":"<pre><code>vertical_regrid(dataset, vertical_coord, levels, method=\"linear\", kwargs={})\n</code></pre> <p>Vertically regrid the dataset.</p> <p>Regrid onto specified levels using preferred method of regridding (wraps xarray.Dataset.interp). https://docs.xarray.dev/en/stable/generated/xarray.Dataset.interp.html</p> <p>Args:</p> <ul> <li><code>dataset</code> (xarray.Dataset): object to be verticaly regridded</li> <li><code>vertical_coord</code> (str): coordinate name of the vertical.</li> <li><code>levels</code> (array_like): levels to interpolate Dataset onto.</li> <li><code>method</code> (str): interpolation method (see xr documentation for more info).</li> <li><code>kwargs</code> (dict): other arguments to pass to xarray.Dataset.interp.</li> </ul> <p>Returns: regridded xarray.Dataset object.</p> <p></p>"},{"location":"references/regrid/#function-infill","title":"function <code>infill</code>","text":"<pre><code>infill(arr_in, n_iter=None, bathy=None)\n</code></pre> <p>Floodfill missing data.</p> <p>Returns data with any NaNs replaced by iteratively taking the geometric mean of surrounding points until all NaNs are removed or n_inter-ations have been performed. Input data must be 2D and can include a bathymetry array as to provide land barriers to the infilling.</p> <p>Args:</p> <ul> <li><code>arr_in</code> (ndarray): data array 2D</li> <li><code>n_iter</code> (int): number of smoothing iterations</li> <li><code>bathy</code> (ndarray): bathymetry array (land set to zero)</li> </ul> <p>Returns:</p> <ul> <li><code>arr_mod</code> (ndarray): modified data array</li> </ul> <p></p>"},{"location":"references/regrid/#function-test_wet_points_populated","title":"function <code>test_wet_points_populated</code>","text":"<pre><code>test_wet_points_populated(regridded_ds, dest_mask)\n</code></pre> <p>Test that wet points have been populated after regridding.</p> <p>Args:</p> <ul> <li><code>regridded_ds</code> (xarray.Dataset): regridded dataset object</li> <li><code>dest_mask</code> (ndarray): landsea mask for destination grid</li> </ul> <p>Returns:</p> <ul> <li><code>regridded_ds</code> (xarray.Dataset): regridded dataset object, infill function used if data are missing.</li> </ul> <p></p>"},{"location":"references/regrid/#function-regrid_data","title":"function <code>regrid_data</code>","text":"<pre><code>regrid_data(\n    source_data,\n    dest_grid=None,\n    regridder=None,\n    regrid_vertically=False,\n    vertical_kwargs={},\n    dest_grid_mask=None,\n)\n</code></pre> <p>Regrid the source data onto the destination grid using the specified regridder.</p> <p>One of dest_grid or regridder must be provided. If no regridder provided then one is made using the dest_grid.</p> <p>Args:</p> <ul> <li><code>source_data</code> (GRID): The source data instance.</li> <li><code>dest_grid</code> (GRID, optional): The destination grid instance.</li> <li><code>regridder</code> (xesmf.Regridder, optional): The regridder object to use.</li> <li><code>regrid_vertically</code> (bool,optional): whether to regrid vertically</li> <li><code>vertical_kwargs</code> (dict, optional): dict containing arguments for vertical_regrid function. Must contain \"vertical_coord\" and \"levels\" as a minimum.</li> </ul> <p>Returns:</p> <ul> <li><code>xarray.Dataset</code>: The regridded data.</li> </ul> <p>Raises:</p> <ul> <li><code>Exception</code>: If neither dest_grid nor regridder is provided.</li> </ul> <p>This file was automatically generated via lazydocs.</p>"}]}